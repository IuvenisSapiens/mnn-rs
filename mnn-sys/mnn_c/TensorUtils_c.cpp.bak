#include "TensorUtils_c.h"
#include "TensorUtils.hpp"
extern "C" {
NativeInsideDescribe *TensorUtils_getDescribe(const Tensor *tensor) {
  return reinterpret_cast<NativeInsideDescribe *>(
      MNN::TensorUtils::getDescribe(tensor));
}
void TensorUtils_copyShape(const Tensor *source, Tensor *dest, int copyFormat,
                           int copyRef) {
  MNN::TensorUtils::copyShape(source, dest, copyFormat, copyRef);
}
void TensorUtils_setShapeensor* dest, const int* alldims, size_t alldimsSize) {
  std::vector<int> dims(alldims, alldims + alldimsSize);
  MNN::TensorUtils::setShape(dest, dims);
}
void TensorUtils_setLinearLayout(Tensor *tensor) {
  MNN::TensorUtils::setLinearLayout(tensor);
}
int TensorUtils_compareTensors(const Tensor *compareTensor,
                               const Tensor *toTensor, float tolerance,
                               int overall, int printsError,
                               int printsTensors) {
  return MNN::TensorUtils::compareTensors(compareTensor, toTensor, tolerance,
                                          overall, printsError, printsTensors);
}
void TensorUtils_setupTensorInfo(const Tensor *tensor, Tensor *wrapTensor,
                                 MNN_DATA_FORMAT mMidFormat) {
  MNN::TensorUtils::setupTensorInfo(tensor, wrapTensor, mMidFormat);
}
Region TensorUtils_makeFullSlice(Tensor *input) {
  auto region = MNN::TensorUtils::makeFullSlice(input);
  Region cRegion;
  cRegion.src = {
      region.src.offset,
      {region.src.stride[0], region.src.stride[1], region.src.stride[2]}};
  cRegion.dst = {
      region.dst.offset,
      {region.dst.stride[0], region.dst.stride[1], region.dst.stride[2]}};
  cRegion.size[0] = region.size[0];
  cRegion.size[1] = region.size[1];
  cRegion.size[2] = region.size[2];
  cRegion.origin = region.origin;
  return cRegion;
}
int TensorUtils_regionIsFull(Tensor *input) {
  return MNN::TensorUtils::regionIsFull(input);
}
int TensorUtils_isCopyRegion(const Region *region) {
  MNN::Tensor::InsideDescribe::Region cppRegion;
  cppRegion.src = {
      region->src.offset,
      {region->src.stride[0], region->src.stride[1], region->src.stride[2]}};
  cppRegion.dst = {
      region->dst.offset,
      {region->dst.stride[0], region->dst.stride[1], region->dst.stride[2]}};
  cppRegion.size[0] = region->size[0];
  cppRegion.size[1] = region->size[1];
  cppRegion.size[2] = region->size[2];
  cppRegion.origin = region->origin;
  return MNN::TensorUtils::isCopyRegion(cppRegion);
}
int TensorUtils_isTransposeRegion(const Region *region) {
  MNN::Tensor::InsideDescribe::Region cppRegion;
  cppRegion.src = {
      region->src.offset,
      {region->src.stride[0], region->src.stride[1], region->src.stride[2]}};
  cppRegion.dst = {
      region->dst.offset,
      {region->dst.stride[0], region->dst.stride[1], region->dst.stride[2]}};
  cppRegion.size[0] = region->size[0];
  cppRegion.size[1] = region->size[1];
  cppRegion.size[2] = region->size[2];
  cppRegion.origin = region->origin;
  return MNN::TensorUtils::isTransposeRegion(cppRegion);
}
int TensorUtils_isTileRegion(const Region *region) {
  MNN::Tensor::InsideDescribe::Region cppRegion;
  cppRegion.src = {
      region->src.offset,
      {region->src.stride[0], region->src.stride[1], region->src.stride[2]}};
  cppRegion.dst = {region->dst.offset{
      region->dst.stride[0], region->dst.stride[1], region->dst.stride[2]}};
  cppRegion.size[0] = region->size[0];
  cppRegion.size[1] = region->size[1];
  cppRegion.size[2] = region->size[2];
  cppRegion.origin = region->origin;
  return MNN::TensorUtils::isTileRegion(cppRegion);
}
int TensorUtils_isDepthToSpaceRegions(const Tensor *output) {
  return MNN::TensorUtils::isDepthToSpaceRegions(output);
}
int TensorUtils_reshapeSlice(Region *slice, int outside, int inside, int axis) {
  MNN::Tensor::InsideDescribe::Region cppSlice;
  cppSlice.src = {
      slice->src.offset,
      {slice->src.stride[0], slice->src.stride[1], slice->src.stride[2]}};
  cppSlice.dst = {
      slice->dst.offset,
      {slice->dst.stride[0], slice->dst.stride[1], slice->dst.stride[2]}};
  cppSlice.size[0] = slice->size[0];
  cppSlice.size[1] = slice->size[1];
  cppSlice.size[2] = slice->size[2];
  cppSlice.origin = slice->origin;
  return MNN::TensorUtils::reshapeSlice(cppSlice, outside, inside, axis);
}
void TensorUtils_adjustTensorForCompability(Tensor *t) {
  MNN::TensorUtils::adjustTensorForCompability(t);
}
DimensionType TensorUtils_getDimType(const Tensor *t) {
  return static_cast<DimensionType>(MNN::TensorUtils::getDimType(t));
}
float *TensorUtils_getQuantInfo(const Tensor *t, size_t *size) {
  auto quantInfo = MNN::TensorUtils::getQuantInfo(t);
  *size = quantInfo.size();
  float *cQuantInfo = new float[*size];
  std::copy(quantInfo.begin(), quantInfo.end(), cQuantInfo);
  return cQuantInfo;
}
size_t TensorUtils_getRawSize(const Tensor *t) {
  return MNN::TensorUtils::getRawSize(t);
}
void TensorUtils_setRasterInputs(Command *cmd) {
  MNN::TensorUtils::setRasterInputs(cmd);
}
int TensorUtils_refTensorContent(Tensor *dst, const Tensor *src) {
  return MNN::TensorUtils::refTensorContent(dst, src);
}
int TensorUtils_getTensorChannelPack(const Tensor *tensor) {
  return MNN::TensorUtils::getTensorChannelPack(tensor);
}
void TensorUtils_setTensorChannelPack(const Tensor *tensor, int pack) {
  MNN::TensorUtils::setTensorChannelPack(tensor, pack);
}
void TensorUtils_setTensorSupportPack(const Tensor *tensor, int flag) {
  MNN::TensorUtils::setTensorSupportPack(tensor, flag);
}
void TensorUtils_setTensorPad(const Tensor *tensor, int left, int right,
                              int bottom, int top) {
  MNN::TensorUtils::setTensorPad(tensor, left, right, bottom, top);
}
} // extern "C"
